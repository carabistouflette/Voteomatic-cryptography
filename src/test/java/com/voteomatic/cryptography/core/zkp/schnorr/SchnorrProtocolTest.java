package com.voteomatic.cryptography.core.zkp.schnorr;

import com.voteomatic.cryptography.core.zkp.ZkpException;
import com.voteomatic.cryptography.securityutils.HashAlgorithm;
import com.voteomatic.cryptography.securityutils.SHA256HashAlgorithm;
import com.voteomatic.cryptography.securityutils.SecureRandomGenerator;
import com.voteomatic.cryptography.securityutils.SecureRandomGeneratorImpl;
import com.voteomatic.cryptography.securityutils.SecurityUtilException; // Add missing import
import java.math.BigInteger;
import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;

public class SchnorrProtocolTest {

  private SecureRandomGenerator secureRandomGenerator;
  private HashAlgorithm hashAlgorithm;
  private SchnorrProver schnorrProver;
  private SchnorrVerifier schnorrVerifier;

  private BigInteger p; // Prime modulus
  private BigInteger g; // Generator
  private BigInteger q; // Order of the group generated by g
  private BigInteger x; // Witness (secret)
  private BigInteger y; // Public value (y = g^x mod p)

  private SchnorrStatement statement;
  private SchnorrWitness witness;

  @BeforeEach
  void setUp() throws SecurityUtilException { // Add throws clause
    secureRandomGenerator = SecureRandomGeneratorImpl.createDefault();
    hashAlgorithm = new SHA256HashAlgorithm();
    schnorrProver = SchnorrProver.create(hashAlgorithm, secureRandomGenerator);
    schnorrVerifier = SchnorrVerifier.create(hashAlgorithm);

    // Using larger parameters from RFC 3526 Group 2 (512-bit safe prime)
    p =
        new BigInteger(
            "FFFFFFFFFFFFFFFFC90FDAA22168C234C4C6628B80DC1CD129024E088A67CC74020BBEA63B139B22514A08798E3404DDEF9519B3CD3A431B302B0A6DF25F14374FE1356D6D51C245E485B576625E7EC6F44C42E9A637ED6B0BFF5CB6F406B7EDEE386BFB5A899FA5AE9F24117C4B1FE649286651ECE45B3DC2007CB8A163BF0598DA48361C55D39A69163FA8FD24CF5F83655D23DCA3AD961C62F356208552BB9ED529077096966D670C354E4ABC9804F1746C08CA18217C32905E462E36CE3BE39E772C180E86039B2783A2EC07A28FB5C55DF06F4C52C9DE2BCBF6955817183995497CEA956AE515D2261898FA051015728E5A8AACAA68FFFFFFFFFFFFFFFF",
            16);
    g = new BigInteger("2");
    // For a safe prime p = 2q + 1, the order of the subgroup generated by g=2 is q = (p-1)/2
    q = p.subtract(BigInteger.ONE).divide(BigInteger.TWO);

    // Generate witness and corresponding public value
    // Generate a random secret x in [1, q-1]
    // Generate a random secret x in [1, q-1]
    // generateBigInteger(limit) returns in [0, limit-1]
    // So, generate in [0, q-2] and add 1.
    x = secureRandomGenerator.generateBigInteger(q.subtract(BigInteger.ONE)).add(BigInteger.ONE);
    y = g.modPow(x, p);

    statement = SchnorrStatement.create(p, q, g, y); // Corrected argument order
    witness = SchnorrWitness.create(x);
  }

  @Test
  void testProveAndVerify_Success() throws ZkpException {
    // 1. Prover generates proof
    SchnorrProof proof = schnorrProver.generateProof(statement, witness);

    // Assert proof components are not null (basic check)
    Assertions.assertNotNull(proof.getT(), "Proof component 't' should not be null");
    Assertions.assertNotNull(proof.getS(), "Proof component 's' should not be null");

    // 2. Verifier verifies the proof
    boolean isValid = schnorrVerifier.verifyProof(statement, proof);

    // 3. Assert verification is successful
    Assertions.assertTrue(
        isValid,
        "Verification should succeed for a valid proof generated with the correct witness.");
  }

  // Optional: Test for invalid proof verification
  @Test
  void testVerify_InvalidProof_ModifiedS() throws ZkpException {
    // 1. Generate a valid proof
    SchnorrProof proof = schnorrProver.generateProof(statement, witness);

    // 2. Modify the proof slightly to make it invalid
    BigInteger modifiedS = proof.getS().add(BigInteger.ONE).mod(q); // Change s
    SchnorrProof invalidProof = SchnorrProof.create(proof.getT(), modifiedS);

    // 3. Verifier verifies the invalid proof
    boolean isValid = schnorrVerifier.verifyProof(statement, invalidProof);

    // 4. Assert verification fails
    Assertions.assertFalse(
        isValid, "Verification should fail for an invalid proof (modified 's').");
  }

  // Optional: Test for invalid proof verification (modified t)
  @Test
  void testVerify_InvalidProof_ModifiedT() throws ZkpException {
    // 1. Generate a valid proof
    SchnorrProof proof = schnorrProver.generateProof(statement, witness);

    // 2. Modify the proof slightly to make it invalid
    BigInteger modifiedT = proof.getT().add(BigInteger.ONE).mod(p); // Change t
    SchnorrProof invalidProof = SchnorrProof.create(modifiedT, proof.getS());

    // 3. Verifier verifies the invalid proof
    boolean isValid = schnorrVerifier.verifyProof(statement, invalidProof);

    // 4. Assert verification fails
    Assertions.assertFalse(
        isValid, "Verification should fail for an invalid proof (modified 't').");
  }
}
