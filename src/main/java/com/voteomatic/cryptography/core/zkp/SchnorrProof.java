package com.voteomatic.cryptography.core.zkp;

import java.math.BigInteger;
import java.util.Objects;

/**
 * Represents the proof generated by Schnorr's protocol. Contains the commitment (t) and the
 * response (s).
 */
public class SchnorrProof implements Proof {

  private static final long serialVersionUID = 1L;

  private final BigInteger t; // Commitment: t = g^v mod p
  private final BigInteger s; // Response: s = (v - c*x) mod q

  /**
   * Private constructor for SchnorrProof. Validation is done in the factory method.
   *
   * @param t The validated commitment value.
   * @param s The validated response value.
   */
  private SchnorrProof(BigInteger t, BigInteger s) {
    this.t = t; // Assumed non-null by factory method
    this.s = s; // Assumed non-null by factory method
  }

  /**
   * Creates a SchnorrProof instance.
   *
   * @param t The commitment value. Must not be null.
   * @param s The response value. Must not be null.
   * @return A new SchnorrProof instance.
   * @throws IllegalArgumentException if t or s is null.
   */
  public static SchnorrProof create(BigInteger t, BigInteger s) {
    if (t == null) {
      throw new IllegalArgumentException("Proof parameter t cannot be null");
    }
    if (s == null) {
      throw new IllegalArgumentException("Proof parameter s cannot be null");
    }
    return new SchnorrProof(t, s);
  }

  public BigInteger getT() {
    return t;
  }

  public BigInteger getS() {
    return s;
  }

  @Override
  public boolean equals(Object o) {
    if (this == o) return true;
    if (o == null || getClass() != o.getClass()) return false;
    SchnorrProof that = (SchnorrProof) o;
    return Objects.equals(t, that.t) && Objects.equals(s, that.s);
  }

  @Override
  public int hashCode() {
    return Objects.hash(t, s);
  }

  @Override
  public String toString() {
    return "SchnorrProof{" + "t=" + t + ", s=" + s + '}';
  }
}
