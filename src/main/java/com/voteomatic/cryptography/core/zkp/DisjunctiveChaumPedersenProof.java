package com.voteomatic.cryptography.core.zkp;

import java.math.BigInteger;
import java.util.Objects;

/**
 * Represents the proof generated by the Disjunctive Chaum-Pedersen prover.
 * It contains components for both potential branches (v=0 and v=1) of the proof.
 *
 * The proof consists of commitments (a0, b0, a1, b1) and challenge-responses
 * (c0, r0, c1, r1) for both potential branches (v=0 and v=1) of the proof.
 * The verifier recalculates the overall challenge c = H(...) and checks c = c0 + c1 mod q.
 * Note: c = c0 + c1 (mod q), where q is the group order.
 */
public class DisjunctiveChaumPedersenProof implements Proof {

    private final BigInteger a0; // Commitment component 1 for v=0 (g^w0 or simulated)
    private final BigInteger b0; // Commitment component 2 for v=0 (h^w0 or simulated)
    private final BigInteger c0; // Challenge for v=0 (real or simulated)
    private final BigInteger r0; // Response for v=0 (w0 + c0*r or simulated)

    private final BigInteger a1; // Commitment component 1 for v=1 (g^w1 or simulated)
    private final BigInteger b1; // Commitment component 2 for v=1 (h^w1 or simulated)
    private final BigInteger c1; // Challenge for v=1 (real or simulated)
    private final BigInteger r1; // Response for v=1 (w1 + c1*r or simulated)

    public DisjunctiveChaumPedersenProof(BigInteger a0, BigInteger b0, BigInteger c0, BigInteger r0,
                                         BigInteger a1, BigInteger b1, BigInteger c1, BigInteger r1) {
        // Add null checks for all parameters
        this.a0 = Objects.requireNonNull(a0, "a0 cannot be null");
        this.b0 = Objects.requireNonNull(b0, "b0 cannot be null");
        this.c0 = Objects.requireNonNull(c0, "c0 cannot be null");
        this.r0 = Objects.requireNonNull(r0, "r0 cannot be null");
        this.a1 = Objects.requireNonNull(a1, "a1 cannot be null");
        this.b1 = Objects.requireNonNull(b1, "b1 cannot be null");
        this.c1 = Objects.requireNonNull(c1, "c1 cannot be null");
        this.r1 = Objects.requireNonNull(r1, "r1 cannot be null");
        // Removed 'c' field
    }

    // Getters for all fields
    public BigInteger getA0() { return a0; }
    public BigInteger getB0() { return b0; }
    public BigInteger getC0() { return c0; }
    public BigInteger getR0() { return r0; }
    public BigInteger getA1() { return a1; }
    public BigInteger getB1() { return b1; }
    public BigInteger getC1() { return c1; }
    public BigInteger getR1() { return r1; }
    // Removed getC()

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        DisjunctiveChaumPedersenProof that = (DisjunctiveChaumPedersenProof) o;
        return Objects.equals(a0, that.a0) &&
               Objects.equals(b0, that.b0) &&
               Objects.equals(c0, that.c0) &&
               Objects.equals(r0, that.r0) &&
               Objects.equals(a1, that.a1) &&
               Objects.equals(b1, that.b1) &&
               Objects.equals(c1, that.c1) &&
               Objects.equals(r1, that.r1);
    }

    @Override
    public int hashCode() {
        return Objects.hash(a0, b0, c0, r0, a1, b1, c1, r1);
    }

    @Override
    public String toString() {
        return "DisjunctiveChaumPedersenProof{" +
               "a0=" + a0 +
               ", b0=" + b0 +
               ", c0=" + c0 +
               ", r0=" + r0 +
               ", a1=" + a1 +
               ", b1=" + b1 +
               ", c1=" + c1 +
               ", r1=" + r1 +
               '}';
    }
}