package com.voteomatic.cryptography.keymanagement;

import com.voteomatic.cryptography.core.elgamal.PrivateKey;
import com.voteomatic.cryptography.core.elgamal.PublicKey;
import com.voteomatic.cryptography.io.DataHandlingException;
import com.voteomatic.cryptography.io.KeyStorageHandler;
import com.voteomatic.cryptography.securityutils.SecureRandomGenerator;

import java.io.*;
import java.math.BigInteger;
import java.util.Objects;

/**
 * Implementation of the KeyService interface.
 * Handles ElGamal key pair generation, storage, and retrieval using a KeyStorageHandler.
 * The ElGamal parameters (prime p, generator g) are provided during construction.
 */
public class KeyServiceImpl implements KeyService {

    private final KeyStorageHandler keyStorageHandler;
    private final SecureRandomGenerator secureRandomGenerator;
    private final BigInteger p; // Prime modulus for this service instance
    private final BigInteger g; // Generator for this service instance

    // Suffixes for storing key parts
    private static final String PUBLIC_KEY_SUFFIX = "_public";
    private static final String PRIVATE_KEY_SUFFIX = "_private";

    /**
     * Constructs a KeyServiceImpl with the required dependencies and ElGamal parameters.
     *
     * @param p                   The prime modulus (p) for ElGamal operations. Must be non-null.
     * @param g                   The generator (g) for ElGamal operations. Must be non-null.
     * @param keyStorageHandler     The handler for storing and retrieving key data. Must be non-null.
     * @param secureRandomGenerator The generator for secure random numbers. Must be non-null.
     */
    public KeyServiceImpl(BigInteger p, BigInteger g, KeyStorageHandler keyStorageHandler, SecureRandomGenerator secureRandomGenerator) {
        this.p = Objects.requireNonNull(p, "Prime modulus p cannot be null.");
        this.g = Objects.requireNonNull(g, "Generator g cannot be null.");
        this.keyStorageHandler = Objects.requireNonNull(keyStorageHandler, "KeyStorageHandler cannot be null.");
        this.secureRandomGenerator = Objects.requireNonNull(secureRandomGenerator, "SecureRandomGenerator cannot be null.");
        // Consider adding validation for p (primality) and g (generator properties) here or elsewhere.
    }

    @Override
    public KeyPair generateKeyPair() throws KeyManagementException {
        try {
            // The private key x should be in the range [1, p-2] for safety,
            // or more accurately, related to the order q of the subgroup generated by g.
            // For simplicity, we generate x in [1, p-1].
            // A more robust implementation might use the subgroup order q = (p-1)/k if known.
            // We need x in range [1, p-2] or similar depending on group structure.
            // Using generateBigInteger(limit) gives [0, limit-1].
            // We'll generate in [0, p-2] and add 1 to get [1, p-1].
            BigInteger pMinusTwo = this.p.subtract(BigInteger.valueOf(2)); // Upper bound for generation is p-2
            if (pMinusTwo.compareTo(BigInteger.ZERO) <= 0) {
                 throw new KeyManagementException("Prime p must be greater than 2 for ElGamal.");
            }
            BigInteger x = secureRandomGenerator.generateBigInteger(pMinusTwo).add(BigInteger.ONE); // x is now in [1, p-1]
            // Note: A check for subgroup order 'q' would be more precise if 'g' generates a subgroup.
            // For the standard MODP group with g=2, the order is (p-1)/2. Generating x < q would be better.
            // BigInteger q = this.p.subtract(BigInteger.ONE).divide(BigInteger.TWO);
            // x = secureRandomGenerator.generateBigInteger(q.subtract(BigInteger.ONE)).add(BigInteger.ONE); // x in [1, q-1]

            /* Original simpler logic using random bits - less precise range control
            do {
                 // Generate x with the same bit length as p, ensuring it's less than p-1
                 x = secureRandomGenerator.generateRandomBits(this.p.bitLength()).mod(pMinusOne);
             } while (x.equals(BigInteger.ZERO)); // Ensure x is not 0
             */

            // Calculate public key y = g^x mod p
            BigInteger y = this.g.modPow(x, this.p);

            // Use the instance's p and g when creating key objects
            PublicKey publicKey = new PublicKey(this.p, this.g, y);
            PrivateKey privateKey = new PrivateKey(this.p, this.g, x);

            return new KeyPair(publicKey, privateKey);

        } catch (Exception e) {
            // Catching generic Exception for unexpected issues during generation
            throw new KeyManagementException("Failed to generate ElGamal key pair", e);
        }
    }

    @Override
    public void storeKeyPair(KeyPair keyPair, String keyId) throws KeyManagementException { // Signature corrected
        if (keyId == null || keyId.trim().isEmpty()) {
            throw new KeyManagementException("Key ID cannot be null or empty.");
        }
        if (keyPair == null || keyPair.getPublicKey() == null || keyPair.getPrivateKey() == null) {
            throw new KeyManagementException("KeyPair and its components cannot be null.");
        }
        // Verify the keypair parameters match the service instance parameters
        if (!this.p.equals(keyPair.getPublicKey().getP()) || !this.g.equals(keyPair.getPublicKey().getG())) {
             throw new KeyManagementException("KeyPair parameters (p, g) do not match the parameters configured for this KeyService instance.");
        }


        try {
            byte[] publicKeyBytes = serialize(keyPair.getPublicKey());
            byte[] privateKeyBytes = serialize(keyPair.getPrivateKey());

            keyStorageHandler.writeData(keyId + PUBLIC_KEY_SUFFIX, publicKeyBytes);
            keyStorageHandler.writeData(keyId + PRIVATE_KEY_SUFFIX, privateKeyBytes);

        } catch (DataHandlingException | IOException e) {
            throw new KeyManagementException("Failed to store key pair with ID: " + keyId, e);
        }
    }

    @Override // Added missing annotation
    public KeyPair retrieveKeyPair(String keyId) throws KeyManagementException {
        if (keyId == null || keyId.trim().isEmpty()) {
            throw new KeyManagementException("Key ID cannot be null or empty.");
        }

        try {
            byte[] publicKeyBytes = keyStorageHandler.readData(keyId + PUBLIC_KEY_SUFFIX);
            byte[] privateKeyBytes = keyStorageHandler.readData(keyId + PRIVATE_KEY_SUFFIX);

            PublicKey publicKey = deserialize(publicKeyBytes, PublicKey.class);
            PrivateKey privateKey = deserialize(privateKeyBytes, PrivateKey.class);

            // Basic validation after retrieval
            if (publicKey == null || privateKey == null) {
                 throw new KeyManagementException("Retrieved key components are null for ID: " + keyId);
            }
            // Verify the retrieved key parameters match the service instance parameters
            if (!this.p.equals(publicKey.getP()) || !this.g.equals(publicKey.getG())) {
                 throw new KeyManagementException("Retrieved KeyPair parameters (p, g) do not match the parameters configured for this KeyService instance. Key ID: " + keyId);
            }
             if (!publicKey.getP().equals(privateKey.getP()) || !publicKey.getG().equals(privateKey.getG())) {
                 throw new KeyManagementException("Retrieved public and private key components have mismatched parameters (p, g) for ID: " + keyId);
            }


            return new KeyPair(publicKey, privateKey);

        } catch (DataHandlingException | IOException | ClassNotFoundException e) {
            throw new KeyManagementException("Failed to retrieve key pair with ID: " + keyId, e);
        }
    }

    @Override // Added missing annotation
    public PublicKey getPublicKey(String keyId) throws KeyManagementException {
         if (keyId == null || keyId.trim().isEmpty()) {
            throw new KeyManagementException("Key ID cannot be null or empty.");
        }
        try {
            byte[] publicKeyBytes = keyStorageHandler.readData(keyId + PUBLIC_KEY_SUFFIX);
            PublicKey publicKey = deserialize(publicKeyBytes, PublicKey.class);

            if (publicKey == null) {
                 throw new KeyManagementException("Retrieved public key is null for ID: " + keyId);
            }
            // Verify the retrieved key parameters match the service instance parameters
            if (!this.p.equals(publicKey.getP()) || !this.g.equals(publicKey.getG())) {
                 throw new KeyManagementException("Retrieved PublicKey parameters (p, g) do not match the parameters configured for this KeyService instance. Key ID: " + keyId);
            }

            return publicKey;

        } catch (DataHandlingException | IOException | ClassNotFoundException e) {
            throw new KeyManagementException("Failed to retrieve public key with ID: " + keyId, e);
        }
    }

    @Override // Signature corrected to match interface
    public boolean verifyKeyIntegrity(PublicKey publicKey) throws KeyManagementException {
         if (publicKey == null) {
            throw new KeyManagementException("PublicKey cannot be null for verification.");
        }

         // Check 1: Ensure public key components are present
        if (publicKey.getP() == null || publicKey.getG() == null || publicKey.getY() == null) {
            return false; // Null components
        }

         // Check 2: Verify the public key parameters match the service instance parameters
        if (!this.p.equals(publicKey.getP()) || !this.g.equals(publicKey.getG())) {
            // The key uses different p or g than this service instance is configured for.
            return false;
        }

        // Check 3: Basic validation of y (e.g., y should be in [1, p-1])
        // y = g^x mod p. Since 1 <= x <= p-2 (or q-1), y should not be 0 or 1 typically,
        // unless g has small order or x=p-1 (which we avoid).
        // A simple check is that y is within the valid range.
        if (publicKey.getY().compareTo(BigInteger.ONE) < 0 || publicKey.getY().compareTo(this.p) >= 0) {
             // y is out of the expected range [1, p-1]
             return false;
        }

        // Add more sophisticated checks if needed, e.g., checking if y is in the subgroup generated by g.
        // For g=2 and p being a safe prime (p=2q+1), this means checking if y^q mod p == 1.
        // BigInteger q = this.p.subtract(BigInteger.ONE).divide(BigInteger.TWO);
        // if (!publicKey.getY().modPow(q, this.p).equals(BigInteger.ONE)) {
        //     return false; // y is not in the quadratic residue subgroup
        // }

        // If all checks pass, consider the public key structurally valid in the context of this service.
        return true;
    }

    // --- Helper Methods for Serialization ---

    private byte[] serialize(Object obj) throws IOException {
        if (!(obj instanceof Serializable)) {
            // This check might be redundant now that PublicKey/PrivateKey implement Serializable,
            // but kept for robustness if other types were serialized.
            throw new IOException("Object of class " + obj.getClass().getName() + " is not Serializable.");
        }
        try (ByteArrayOutputStream bos = new ByteArrayOutputStream();
             ObjectOutputStream oos = new ObjectOutputStream(bos)) {
            oos.writeObject(obj);
            return bos.toByteArray();
        }
    }

    @SuppressWarnings("unchecked") // Suppress warning for cast, protected by class check
    private <T> T deserialize(byte[] data, Class<T> type) throws IOException, ClassNotFoundException {
         if (!Serializable.class.isAssignableFrom(type)) {
             // Redundant check, similar to serialize method.
            throw new IOException("Class " + type.getName() + " is not Serializable and cannot be deserialized.");
        }
        try (ByteArrayInputStream bis = new ByteArrayInputStream(data);
             ObjectInputStream ois = new ObjectInputStream(bis)) {
            Object obj = ois.readObject();
            if (type.isInstance(obj)) {
                return (T) obj;
            } else {
                throw new IOException("Deserialized object type mismatch. Expected " + type.getName() + " but got " + obj.getClass().getName());
            }
        }
    }
}