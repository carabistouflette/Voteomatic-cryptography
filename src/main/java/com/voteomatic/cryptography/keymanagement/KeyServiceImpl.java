package com.voteomatic.cryptography.keymanagement;

import com.voteomatic.cryptography.core.elgamal.PrivateKey;
import com.voteomatic.cryptography.core.elgamal.PublicKey;
import com.voteomatic.cryptography.io.DataHandlingException;
import com.voteomatic.cryptography.io.KeyStorageHandler;
import com.voteomatic.cryptography.securityutils.SecureRandomGenerator;

import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.DataInputStream;
import java.io.DataOutputStream;
import java.io.IOException;
import java.math.BigInteger;
import java.util.Objects;

/**
 * Implementation of the KeyService interface.
 * Handles ElGamal key pair generation, storage, and retrieval using a KeyStorageHandler.
 * The ElGamal parameters (prime p, generator g) are provided during construction.
 */
public class KeyServiceImpl implements KeyService {

    private final KeyStorageHandler keyStorageHandler;
    private final SecureRandomGenerator secureRandomGenerator;
    private final BigInteger p;
    private final BigInteger g;

    private static final String PUBLIC_KEY_SUFFIX = "_public";
    private static final String PRIVATE_KEY_SUFFIX = "_private";

    /**
     * Constructs a KeyServiceImpl with the required dependencies and ElGamal parameters.
     *
     * @param p                   The prime modulus (p) for ElGamal operations. Must be non-null.
     * @param g                   The generator (g) for ElGamal operations. Must be non-null.
     * @param keyStorageHandler     The handler for storing and retrieving key data. Must be non-null.
     * @param secureRandomGenerator The generator for secure random numbers. Must be non-null.
     */
    public KeyServiceImpl(BigInteger p, BigInteger g, KeyStorageHandler keyStorageHandler, SecureRandomGenerator secureRandomGenerator) {
        this.p = Objects.requireNonNull(p, "Prime modulus p cannot be null.");
        this.g = Objects.requireNonNull(g, "Generator g cannot be null.");
        this.keyStorageHandler = Objects.requireNonNull(keyStorageHandler, "KeyStorageHandler cannot be null.");
        this.secureRandomGenerator = Objects.requireNonNull(secureRandomGenerator, "SecureRandomGenerator cannot be null.");
        // Consider adding validation for p (primality) and g (generator properties) here or elsewhere.
    }

    @Override
    public KeyPair generateKeyPair() throws KeyManagementException {
        try {
            // The private key x should be in the range [1, p-2] for safety,
            // or more accurately, related to the order q of the subgroup generated by g.
            // For simplicity, we generate x in [1, p-1].
            // A more robust implementation might use the subgroup order q = (p-1)/k if known.
            // We need x in range [1, p-2] or similar depending on group structure.
            // Using generateBigInteger(limit) gives [0, limit-1].
            // We'll generate in [0, p-2] and add 1 to get [1, p-1].
            BigInteger pMinusTwo = this.p.subtract(BigInteger.valueOf(2)); // Upper bound for generation is p-2
            if (pMinusTwo.compareTo(BigInteger.ZERO) <= 0) {
                 throw new KeyManagementException("Prime p must be greater than 2 for ElGamal.");
            }
            BigInteger x = secureRandomGenerator.generateBigInteger(pMinusTwo).add(BigInteger.ONE); // x is now in [1, p-1]
            // Note: A check for subgroup order 'q' would be more precise if 'g' generates a subgroup.
            // For the standard MODP group with g=2, the order is (p-1)/2. Generating x < q would be better.
            // BigInteger q = this.p.subtract(BigInteger.ONE).divide(BigInteger.TWO);
            // x = secureRandomGenerator.generateBigInteger(q.subtract(BigInteger.ONE)).add(BigInteger.ONE); // x in [1, q-1]


            BigInteger y = this.g.modPow(x, this.p);

            // Use the instance's p and g when creating key objects
            PublicKey publicKey = new PublicKey(this.p, this.g, y);
            PrivateKey privateKey = new PrivateKey(this.p, this.g, x);

            return new KeyPair(publicKey, privateKey);

        } catch (Exception e) {
            throw new KeyManagementException("Failed to generate ElGamal key pair", e);
        }
    }

    @Override
    public void storeKeyPair(KeyPair keyPair, String keyId) throws KeyManagementException {
        if (keyId == null || keyId.trim().isEmpty()) {
            throw new KeyManagementException("Key ID cannot be null or empty.");
        }
        if (keyPair == null || keyPair.getPublicKey() == null || keyPair.getPrivateKey() == null) {
            throw new KeyManagementException("KeyPair and its components cannot be null.");
        }
        // Verify the keypair parameters match the service instance parameters
        if (!this.p.equals(keyPair.getPublicKey().getP()) || !this.g.equals(keyPair.getPublicKey().getG())) {
             throw new KeyManagementException("KeyPair parameters (p, g) do not match the parameters configured for this KeyService instance.");
        }


        try {
            byte[] publicKeyBytes = serializePublicKey(keyPair.getPublicKey());
            byte[] privateKeyBytes = serializePrivateKey(keyPair.getPrivateKey());

            keyStorageHandler.writeData(keyId + PUBLIC_KEY_SUFFIX, publicKeyBytes);
            keyStorageHandler.writeData(keyId + PRIVATE_KEY_SUFFIX, privateKeyBytes);

        } catch (DataHandlingException | IOException e) {
            throw new KeyManagementException("Failed to store key pair with ID: " + keyId, e);
        }
    }

    @Override
    public KeyPair retrieveKeyPair(String keyId) throws KeyManagementException {
        if (keyId == null || keyId.trim().isEmpty()) {
            throw new KeyManagementException("Key ID cannot be null or empty.");
        }

        try {
            byte[] publicKeyBytes = keyStorageHandler.readData(keyId + PUBLIC_KEY_SUFFIX);
            byte[] privateKeyBytes = keyStorageHandler.readData(keyId + PRIVATE_KEY_SUFFIX);

            PublicKey publicKey = deserializePublicKey(publicKeyBytes);
            PrivateKey privateKey = deserializePrivateKey(privateKeyBytes);

            if (publicKey == null || privateKey == null) {
                 throw new KeyManagementException("Retrieved key components are null for ID: " + keyId);
            }
            // Verify the retrieved key parameters match the service instance parameters
            if (!this.p.equals(publicKey.getP()) || !this.g.equals(publicKey.getG())) {
                 throw new KeyManagementException("Retrieved KeyPair parameters (p, g) do not match the parameters configured for this KeyService instance. Key ID: " + keyId);
            }
             if (!publicKey.getP().equals(privateKey.getP()) || !publicKey.getG().equals(privateKey.getG())) {
                 throw new KeyManagementException("Retrieved public and private key components have mismatched parameters (p, g) for ID: " + keyId);
            }


            return new KeyPair(publicKey, privateKey);

        } catch (DataHandlingException | IOException e) {
            throw new KeyManagementException("Failed to retrieve key pair with ID: " + keyId, e);
        }
    }

    @Override
    public PublicKey getPublicKey(String keyId) throws KeyManagementException {
         if (keyId == null || keyId.trim().isEmpty()) {
            throw new KeyManagementException("Key ID cannot be null or empty.");
        }
        try {
            byte[] publicKeyBytes = keyStorageHandler.readData(keyId + PUBLIC_KEY_SUFFIX);
            PublicKey publicKey = deserializePublicKey(publicKeyBytes);

            if (publicKey == null) {
                 throw new KeyManagementException("Retrieved public key is null for ID: " + keyId);
            }
            // Verify the retrieved key parameters match the service instance parameters
            if (!this.p.equals(publicKey.getP()) || !this.g.equals(publicKey.getG())) {
                 throw new KeyManagementException("Retrieved PublicKey parameters (p, g) do not match the parameters configured for this KeyService instance. Key ID: " + keyId);
            }

            return publicKey;

        } catch (DataHandlingException | IOException e) {
            throw new KeyManagementException("Failed to retrieve public key with ID: " + keyId, e);
        }
    }

    @Override
    public boolean verifyKeyIntegrity(PublicKey publicKey) throws KeyManagementException {
         if (publicKey == null) {
            throw new KeyManagementException("PublicKey cannot be null for verification.");
        }

        if (publicKey.getP() == null || publicKey.getG() == null || publicKey.getY() == null) {
            return false; // Null components
        }

        if (!this.p.equals(publicKey.getP()) || !this.g.equals(publicKey.getG())) {
            // The key uses different p or g than this service instance is configured for.
            return false;
        }

        // y = g^x mod p. Since 1 <= x <= p-2 (or q-1), y should not be 0 or 1 typically,
        // unless g has small order or x=p-1 (which we avoid).
        // A simple check is that y is within the valid range.
        if (publicKey.getY().compareTo(BigInteger.ONE) < 0 || publicKey.getY().compareTo(this.p) >= 0) {
             // y is out of the expected range [1, p-1]
             return false;
        }

        // Add more sophisticated checks if needed, e.g., checking if y is in the subgroup generated by g.
        // For g=2 and p being a safe prime (p=2q+1), this means checking if y^q mod p == 1.
        // BigInteger q = this.p.subtract(BigInteger.ONE).divide(BigInteger.TWO);
        // if (!publicKey.getY().modPow(q, this.p).equals(BigInteger.ONE)) {
        //     return false; // y is not in the quadratic residue subgroup
        // }

        // If all checks pass, consider the public key structurally valid in the context of this service.
        return true;
    }


    private byte[] serializePublicKey(PublicKey key) throws IOException {
        try (ByteArrayOutputStream bos = new ByteArrayOutputStream();
             DataOutputStream dos = new DataOutputStream(bos)) {
            serializeBigInteger(dos, key.getP());
            serializeBigInteger(dos, key.getG());
            serializeBigInteger(dos, key.getY());
            return bos.toByteArray();
        }
    }

    private PublicKey deserializePublicKey(byte[] data) throws IOException {
        try (ByteArrayInputStream bis = new ByteArrayInputStream(data);
             DataInputStream dis = new DataInputStream(bis)) {
            BigInteger p = deserializeBigInteger(dis);
            BigInteger g = deserializeBigInteger(dis);
            BigInteger y = deserializeBigInteger(dis);
            // Ensure retrieved keys match service parameters
            if (!this.p.equals(p) || !this.g.equals(g)) {
                 throw new IOException("Deserialized PublicKey parameters (p, g) do not match service configuration.");
            }
            return new PublicKey(p, g, y);
        }
    }

     private byte[] serializePrivateKey(PrivateKey key) throws IOException {
        try (ByteArrayOutputStream bos = new ByteArrayOutputStream();
             DataOutputStream dos = new DataOutputStream(bos)) {
            serializeBigInteger(dos, key.getP());
            serializeBigInteger(dos, key.getG());
            serializeBigInteger(dos, key.getX());
            return bos.toByteArray();
        }
    }

    private PrivateKey deserializePrivateKey(byte[] data) throws IOException {
        try (ByteArrayInputStream bis = new ByteArrayInputStream(data);
             DataInputStream dis = new DataInputStream(bis)) {
            BigInteger p = deserializeBigInteger(dis);
            BigInteger g = deserializeBigInteger(dis);
            BigInteger x = deserializeBigInteger(dis);
             // Ensure retrieved keys match service parameters
            if (!this.p.equals(p) || !this.g.equals(g)) {
                 throw new IOException("Deserialized PrivateKey parameters (p, g) do not match service configuration.");
            }
            return new PrivateKey(p, g, x);
        }
    }

    private void serializeBigInteger(DataOutputStream dos, BigInteger bi) throws IOException {
        byte[] bytes = bi.toByteArray();
        dos.writeInt(bytes.length);
        dos.write(bytes);
    }

    private BigInteger deserializeBigInteger(DataInputStream dis) throws IOException {
        int length = dis.readInt();
        if (length < 0) {
             throw new IOException("Invalid length read for BigInteger: " + length);
        }
        // Prevent OOM errors from malicious data
        if (length > 10 * 1024 * 1024) { // e.g., 10MB limit
            throw new IOException("BigInteger length exceeds safety limit: " + length);
        }
        byte[] bytes = new byte[length];
        dis.readFully(bytes);
        return new BigInteger(bytes);
    }
}